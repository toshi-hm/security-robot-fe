# セキュリティロボット強化学習システム - 自己完結型設計書パッケージ

## 📚 ドキュメント概要

このディレクトリには、セキュリティロボット強化学習システムの**完全自己完結型設計書**が含まれています。すべてのドキュメントは、このリポジトリの内容を知らない人でも、システムの設計・実装が理解できるように作成されています。

**重要な特徴:**
- ✅ ファイルパス参照なし(例: `src/~~/hoge.py` のような記述なし)
- ✅ 具体的な実装内容の詳細説明
- ✅ コード例・データ構造・API仕様の明示
- ✅ 技術的根拠の説明
- ✅ 初見の開発者が実装可能なレベルの詳細度

## 📖 ドキュメント一覧

### 1. システムアーキテクチャ設計書 (850行)
**ファイル:** `01_system_architecture_design_standalone.md`

**内容:**
- プロジェクト概要と研究背景の詳細
- 3層アーキテクチャ(フロント・バック・インフラ)の設計
- 強化学習システムの詳細(PPO/A3Cアルゴリズム実装)
- データフロー設計とWebSocket通信プロトコル
- データベース設計(PostgreSQL スキーマ)
- セキュリティ・パフォーマンス・デプロイメント戦略

**主要トピック:**
```
1. プロジェクト概要 (研究背景・課題・アプローチ)
2. システム全体アーキテクチャ (3層構造詳細)
3. 強化学習システムの詳細設計
   - 環境設計 (観測空間・行動空間・報酬関数)
   - PPOアルゴリズム実装 (Stable-Baselines3)
   - A3Cアルゴリズム実装 (カスタムPyTorch)
4. データフローとリアルタイム通信
   - 学習開始から完了までのフロー
   - WebSocketメッセージフォーマット
   - 非同期処理とパフォーマンス最適化
5. セキュリティと品質保証
6. 運用と監視
7. まとめと今後の拡張性
```

### 2. バックエンドAPI設計書 (780行)
**ファイル:** `02_backend_api_design_standalone.md`

**内容:**
- FastAPI + PostgreSQL + Redis + Celeryの詳細設計
- RESTful APIエンドポイント仕様
- WebSocket通信実装
- データベーススキーマとSQLAlchemyモデル
- サービス層・リポジトリ層の設計
- Celeryバックグラウンドタスク実装
- 強化学習エンジン統合

**主要トピック:**
```
1. バックエンドAPI概要 (技術スタック・アーキテクチャパターン)
2. ディレクトリ構造と各モジュールの責務
3. データベース設計
   - テーブル定義 (SQL DDL)
   - SQLAlchemyモデル実装
   - Pydanticスキーマ定義
4. API エンドポイント詳細仕様
   - POST /training/start (学習開始)
   - POST /training/{id}/stop (学習停止)
   - GET /training/{id}/status (状態取得)
   - GET /training/{id}/metrics (メトリクス取得)
   - WebSocket /ws/training/{session_id}
5. サービス層実装 (TrainingService詳細)
6. Celeryバックグラウンドタスク
7. 強化学習エンジン統合 (PPOTrainer実装)
```

### 3. フロントエンド設計書 (作成予定)
**ファイル:** `03_frontend_design_standalone.md`

**予定内容:**
- Vue.js 3 + Nuxt v4 + TypeScript設計
- DDD(Domain-Driven Design)適用
- Element Plus UIコンポーネント設計
- Pinia状態管理
- WebSocketリアルタイム通信
- Chart.js/D3.js可視化実装

### 4. 実装プロンプトセット (作成予定)
**ディレクトリ:** `prompts/`

**予定内容:**
- AI実装者向けの段階的実装指示
- バックエンド実装プロンプト
- フロントエンド実装プロンプト
- テスト実装プロンプト
- デプロイメントプロンプト

## 🎯 ドキュメントの使い方

### 初めて読む方へ

1. **システムアーキテクチャ設計書**から読み始めることを推奨
   - プロジェクト全体の理解
   - 技術スタックの選定理由
   - データフローの把握

2. **役割に応じた読み方:**
   - **バックエンド開発者:** システムアーキテクチャ → バックエンドAPI設計書
   - **フロントエンド開発者:** システムアーキテクチャ → フロントエンド設計書
   - **プロジェクトマネージャー:** システムアーキテクチャのみで全体把握
   - **AI実装者:** 実装プロンプトセットから開始

### 実装時の活用方法

**段階的実装:**
```
Phase 1: インフラ準備
  → システムアーキテクチャ設計書 6章「Docker Compose構成」参照

Phase 2: バックエンド実装
  → バックエンドAPI設計書 2-7章を順次実装

Phase 3: フロントエンド実装
  → フロントエンド設計書に従い実装

Phase 4: 統合テスト
  → 各設計書のテスト章を参照

Phase 5: デプロイメント
  → システムアーキテクチャ設計書 9章参照
```

## 🔄 進捗管理とセッション記録

### 進捗ファイル（report/progress.md）
実装を進めるにあたり、**適宜進捗はreport/progress.md に記載すること**:
- ✅ 何を実装したのか（実装済み機能）
- 🔧 何がまだTODOとして残っているのか（未実装項目）
- 進捗ファイルは**編集OK**（最新状態を常に反映）

### セッション日記（report/sessions/）
それとは別に、**1セッションで何を実行したのかを記録する日記ファイル**を別途作成すること:
- ファイル名: `report/sessions/YYYY-MM-DD_session.md` 形式
- 記録内容:
  - セッション開始時刻・終了時刻
  - 実施したタスク（具体的な実装内容）
  - 遭遇した問題と解決方法
  - 次回セッションへの引き継ぎ事項
- **追記専用**（過去のセッション記録は編集しない）

### AI実装者への重要指示
**毎回この進捗ファイルや日記ファイルを読んでから作業に取り掛かること**:

1. **セッション開始時の手順:**
   ```
   1. report/progress.md を読む（現在の進捗確認）
   2. report/sessions/ の最新セッション日記を読む（前回の作業内容確認）
   3. 設計書（instructions/*.md）を参照しながら作業開始
   4. 作業完了後、progress.md を更新
   5. report/sessions/YYYY-MM-DD_session.md を新規作成して記録
   ```

2. **実装ガイド（prompts/）にも同様の指示を記載:**
   - `00_implementation_guide.md` - 全体実装ガイド
   - `01_frontend_implementation_guide.md` - フロントエンド実装ガイド

   これらのガイドの冒頭に「進捗ファイルとセッション日記を読む」手順を追加する。

## 📝 ドキュメントの特徴

### 1. 自己完結性

すべてのドキュメントは独立して読めますが、相互参照も可能です:

```
システムアーキテクチャ設計書
  ├─ 全体像・データフロー
  ├─ 技術選定理由
  └─ デプロイメント戦略

バックエンドAPI設計書
  ├─ 詳細API仕様
  ├─ データベース設計
  └─ 実装コード例

フロントエンド設計書
  ├─ コンポーネント設計
  ├─ 状態管理
  └─ UI/UX詳細
```

### 2. 具体的なコード例

ファイルパスではなく、**実装内容**を説明:

**悪い例:**
```
環境設定はsrc/security_robot_rl/environment.pyで実装されています。
```

**良い例:**
```python
環境設定は以下のように実装します:

class SecurityEnvironment(gym.Env):
    """
    セキュリティロボット環境

    観測空間: 3Dテンソル (W, H, 3)
      - チャンネル0: 脅威レベル (0.0-1.0)
      - チャンネル1: 障害物マップ (0=通行可, 1=障害物)
      - チャンネル2: ロボット位置・向き

    行動空間: 4離散行動
      - 0: 前進
      - 1: 左回転
      - 2: 右回転
      - 3: その場巡回
    """
    def __init__(self, width=8, height=8):
        self.width = width
        self.height = height
        self.observation_space = spaces.Box(
            low=0, high=1,
            shape=(width, height, 3),
            dtype=np.float32
        )
        self.action_space = spaces.Discrete(4)
```

### 3. 技術的根拠の説明

**なぜその設計にしたか**の理由も記載:

例: PostgreSQL選定理由
- JSONB型による柔軟なメタデータ保存
- 複雑なクエリ(JOIN, サブクエリ)のサポート
- エンタープライズグレードの信頼性
- SQLAlchemyとの良好な統合

例: WebSocket使用理由
- 学習進捗のリアルタイム配信が必要
- ポーリングよりも低レイテンシ
- 双方向通信(サーバープッシュ可能)

## 🔧 技術スタック一覧

### バックエンド
- **言語:** Python 3.12
- **Webフレームワーク:** FastAPI 0.104+
- **データベース:** PostgreSQL 15
- **ORM:** SQLAlchemy 2.0
- **タスクキュー:** Celery 5.3
- **メッセージブローカー:** Redis 7
- **強化学習:** PyTorch 2.1, Stable-Baselines3 2.2

### フロントエンド
- **言語:** TypeScript 5.9
- **フレームワーク:** Vue.js 3.5, Nuxt v4
- **UIライブラリ:** Element Plus 3.x
- **状態管理:** Pinia 2.x
- **可視化:** Chart.js 4.5, D3.js 7.x
- **通信:** Socket.IO Client 4.8

### インフラ
- **コンテナ:** Docker, Docker Compose
- **Webサーバー:** Nginx
- **CI/CD:** GitHub Actions

## 📊 システム規模

### データベース
- **テーブル数:** 3 (TrainingSession, TrainingMetrics, EnvironmentState)
- **主要レコード:**
  - 学習セッション: 数百〜数千
  - メトリクス: 数万〜数十万(時系列データ)
  - 環境状態: 数千〜数万(プレイバック用)

### API
- **エンドポイント数:** 15+
- **WebSocketチャンネル:** 複数(セッション別)
- **同時接続:** 10-100(ローカル環境想定)

### フロントエンド
- **ページ数:** 10+
- **コンポーネント数:** 50+
- **状態管理ストア:** 6(training, environment, playback, models, websocket, ui)

## 🚀 実装スケジュール目安

### Phase 1: インフラ準備 (3日)
- Docker Compose環境構築
- PostgreSQL/Redisセットアップ
- 基本的なCI/CD設定

### Phase 2: バックエンド基盤 (5日)
- FastAPI基本構造
- データベースモデル・マイグレーション
- 基本APIエンドポイント(CRUD)

### Phase 3: バックエンド高度機能 (5日)
- WebSocket通信実装
- Celeryタスク統合
- 強化学習エンジン統合

### Phase 4: フロントエンド基盤 (4日)
- Nuxtプロジェクト初期化
- DDD構造実装
- 基本UIコンポーネント

### Phase 5: フロントエンド機能実装 (6日)
- 学習制御画面
- リアルタイム可視化
- プレイバック機能

### Phase 6: 統合・テスト (5日)
- E2Eテスト実装
- パフォーマンステスト
- バグ修正

### Phase 7: デプロイメント (2日)
- 本番環境設定
- ドキュメント最終化
- リリース準備

**合計: 約30日(1人月)**

## 📈 品質基準

### テストカバレッジ
- バックエンド: 90%以上(pytest)
- フロントエンド: 85%以上(Vitest)
- E2Eテスト: 主要ユーザーフロー100%カバー(Playwright)

### パフォーマンス
- API応答時間: < 100ms(学習制御除く)
- WebSocketレイテンシ: < 50ms
- 学習開始レスポンス: < 500ms(非同期タスク起動)

### コード品質
- TypeScript strict mode有効
- ESLint/Prettier設定済み
- Python type hints使用
- SQLAlchemy mypy プラグイン有効

## 🤝 貢献ガイドライン

このドキュメントセットを改善する場合:

1. **自己完結性を維持:**
   - ファイルパス参照を追加しない
   - 具体的な実装内容を記載する

2. **技術的正確性:**
   - コード例は実行可能なものにする
   - 技術選定には理由を明記する

3. **詳細度のバランス:**
   - 初見の開発者が理解できるレベル
   - しかし冗長にならないよう注意

## 📞 サポート

### ドキュメントに関する質問

各設計書の該当章を参照してください:
- **全体設計:** システムアーキテクチャ設計書
- **API詳細:** バックエンドAPI設計書
- **UI/UX:** フロントエンド設計書
- **実装手順:** 実装プロンプトセット

### 技術的な質問

公式ドキュメントを参照:
- FastAPI: https://fastapi.tiangolo.com/
- Vue.js: https://vuejs.org/
- Nuxt: https://nuxt.com/
- Stable-Baselines3: https://stable-baselines3.readthedocs.io/

## 📜 ライセンスと著作権

このドキュメントセットは、セキュリティロボット強化学習研究プロジェクトの一部として作成されました。学術研究および教育目的での使用を想定しています。

---

**最終更新:** 2025年10月5日
**バージョン:** 1.0
**ドキュメント総行数:** 2,600行以上
**ステータス:** システムアーキテクチャ・バックエンド設計完了、フロントエンド・プロンプト作成中
